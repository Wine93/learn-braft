整体流程
===

Leader 侧流程
---
![日志复制整体流程](image/replication-2.svg)

Follower 侧流程
---

*Follower* 接受到 *AppendEntries* 请求后，将直接调用 *LogManager* 的 `AppendEntries` 接口追加日志，除了几下几点差异，其处理流程和上图中的 *Leader* 侧流程基本一致：

*
* *Leader* 在往内存中插入日志会，后唤醒所有的 `Replicator` 给其对应的 *Follower* 发送 *AppendEntries* 请求，而 *Follower* 没有任何 *Replicator*

日志复制失败
---

```cpp
void function(op, callback) {
    braft::Task task;
    ...
    task.done = make_closure(callback);
    ...
    return _node->apply(task);
}
```

用户在构建 *task* 的时候需要指定对应的 *callback*
* 如果日志复制成功，需要用户在 `on_apply` 接口中回调 *callback*
* 如果日志复制失败，将由 *braft* 回调 *callback*，并将 *error* 信息传递给 *callback*

*braft* 在以下

客户端在调用 *apply* 的时候，如果该操作对应的日志被成功被复制并回调 `on_apply`，需要用户在 `on_apply` 接口中主动

当当前 *Leader* 已不是 *Leader* 时，主要发生在以下几个场景：

* 响应: term > current_term

```cpp
status.set_error(EHIGHERTERMRESPONSE, "Leader receives higher term "
                    "%s from peer:%s", response->GetTypeName().c_str(), r->_options.peer_id.to_string().c_str());

```